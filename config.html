<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Totem</title>
  <meta name="generator" content="DocPad v6.73.5" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style >html.wait {
	cursor: wait !important;
	opacity: 0;
	transition: opacity 0.5s ease;
}</style><link  rel="stylesheet" href="styles/vendor/vendor.css" /><link  rel="stylesheet" href="styles/main.css" />
</head>
<body>
  <header class="site-header">
    <div class="site-wrap pure-g">
      <div class="site-logo pure-u-1 pure-u-md-1-4">
        <a href="/"><img src="/images/totem-logo.png" alt="totem" class="pure-img" /></a>
      </div>
      <h1 class="site-tagline pure-u-1 pure-u-md-3-4">Documentation, issues, guides.</h1>
    </div>
    <nav class="site-nav">
      <div class="site-wrap pure-g">
        <div class="pure-u-1">
          <ul class="site-nav-list">
            
              <li class="site-nav-list-item inactive">
                <a href="/assumptions.html">Assumptions</a>
              </li>
            
          </ul>
        </div>
      </div>
    </nav>
  </header>
  <div class="site-wrap pure-g">
    <nav class="content-nav pure-u-1 pure-u-md-1-4">
      <ul class="anchor-links"></ul>
    </nav>
    <div class="site-content pure-u-1 pure-u-md-3-4" role="main">
      <h1 id="totem-config-guide">Totem Config Guide</h1>
<h2 id="about">About</h2>
<p>This guide covers the basics of totem configuration file used per deployed application in totem.</p>
<h2 id="supported-formats">Supported Formats</h2>
<p>Currently <a href="http://yaml.org/">YAML</a> is the only supported configuration format used in totem.</p>
<h2 id="config-names">Config Names</h2>
<p>The totem configuration file names can be be configured during orchestrator provisioning. By default following names
are used:</p>
<ul>
<li><strong>cluster-def.yml</strong> : Typically used at global level to define cluster definition.</li>
<li><strong>totem.yml</strong>: Typically used at global/application level for defining rest of config.
<em>Note: You may break the config into multiple files if needed. In the end , all configs are merged into a single file
during deployment</em></li>
</ul>
<h2 id="config-location">Config Location</h2>
<p>The config can be stored in one or more locations defined by env. variable <strong>CONFIG_PROVIDER_LIST</strong> in orchestrator.
<em>Note: If using AWS, typical approach is to store config in Amazon S3. CONFIG_PROVIDER_LIST=s3</em>
All except (default and github) provider support multi level config where in the config file can be defined:</p>
<ul>
<li>Globally (for all environments ) at path: <strong>/totem/config</strong></li>
<li>Per environment at path: <strong>/totem/config/[env-name]</strong>  e.g.:  /totem/config/production</li>
<li>Per Repository owner at path: <strong>/totem/config/[env-name]/[repo-owner]</strong> e.g.: /totem/config/production/totem</li>
<li>Per Repository at path: <strong>/totem/config/[env-name]/[repo-owner]/[repository]</strong>
e.g.: /totem/config/production/totem/totem-demo</li>
<li>Per Repository branch/tag: <strong>/totem/config/[env-name]/[repo-owner]/[repository]/[ref]</strong>
e.g.: /totem/config/production/totem/totem-demo/develop</li>
</ul>
<h2 id="config-merge">Config Merge</h2>
<p>During a deploy, all configs (multiple files, multiple locations) are merged into a single config that typically
gets cached in etcd store. The merge is performed using nested merge strategy in which config keys defined at branch/tag level takes highest precendence while the one defined globally takes the lowest precendence. In addition if multiple config providers are defined e.g. (etcd,s3,default), the provider occuring first takes precendence over the one occuring later.</p>
<p>e.g. Given 2 configs:</p>
<pre><code class="lang-yaml">deployer:
  deployer1:
    enabled: true
  deployer2:
    enabled: false
</code></pre>
<pre><code class="lang-yaml">deployer:
  deployer1:
    enabled: false
  deployer3:
    enabled: true
</code></pre>
<p>When we merge the 2 configs, the resulting config looks like:</p>
<pre><code class="lang-yaml">deployer:
  deployer1:
    enabled: true
  deployer2:
    enabled: true
  deployer3:
    enabled: true
</code></pre>
<h2 id="encrypted-values">Encrypted Values</h2>
<p>Some sections of totem config can contain encrypted values. It uses asymmetric cryptography using PKCS#1 v1.5. Refer to <a href="https://github.com/totem/cluster-deployer">cluster-deployer</a> guide to enable encryption for a given cluster.
The cluster deployer uses different profiles for encryption. See <a href="#security">Config Schema - Security Section</a> for defining a security profile. The name of default profile is &#39;default&#39;.</p>
<p>If a given config supports encryption, set encrypted property for the config element to true.
e.g.:</p>
<pre><code>deployers:
  default:
    templates:
      app:
        args:
          environment:
            AWS_SECRET_ACCESS_KEY:
              value: &quot;*****encrypted value******&quot;
              encrypted: true
</code></pre><p>In this example, the environment variable &quot;AWS_SECRET_ACCESS_KEY&quot; is injected into the application and its value is marked as injected. The value is decrypted at the final stage of deploy when fleet unit file is created.</p>
<h2 id="config-schema">Config Schema</h2>
<p>Totem config is validated using <a href="http://json-schema.org/">json schema</a>. Currently there are 2 schemas defined for validation:</p>
<ul>
<li><a href="https://github.com/totem/cluster-orchestrator/blob/master/schemas/job-config-v1.json">job-config-v1.json</a>: This schema corresponds to first step in validation phase. This step is applied after all configs are merged to create a single config.</li>
<li><a href="https://github.com/totem/cluster-orchestrator/blob/master/schemas/job-config-v1-evaluated.json">job-config-evaluated-v1.json</a>: This schema corresponds to second step in validation phase. This step is applied after dynamic portions of configs are evaluated.</li>
</ul>
<h2 id="config-elements">Config Elements</h2>
<h3 id="variables">variables</h3>
<h4 id="variables-overview">Variables Overview</h4>
<p>Defines the dynamic values that gets substituted in dynamic section of a given config. Basically it acts as variables for jinja substitution. Refer dynamic section for more details.
e.g.:</p>
<pre><code class="lang-yaml">variables:
  public_host: myapp.myhost.com

proxy:
  hosts:
    public:
      hostname:
        value: &quot;{{public_host}}&quot;
</code></pre>
<p>In this example, the value of hostname is substituted by myapp.myhost.com when config is evaluated.</p>
<h4 id="template-variables">Template variables</h4>
<p>The variables values itself can be evaluated dynamically using jinja templates. The variables are evaluated in order defined by their priority (Variables with lower priority are evaluated first).
e.g.:</p>
<pre><code class="lang-yaml">variables:
  private_host: myapp.myhost.com
  public_host:
    value: &quot;{{public_host}}&quot;
    priority: 2
</code></pre>
<p>In this example the value of variable public_host is evaluated using the value of private_host.</p>
<h3 id="security">security</h3>
<p>This section defines the security settings to be used globally or per application. By default, a &#39;default&#39; security profile is defined. e.g.:</p>
<pre><code class="lang-yaml">security:
  profile: myapp
</code></pre>
<p>In the above example security profile is changed from &#39;default&#39; to &#39;myapp&#39;.  Refer <a href="README.md#encrypted-values">Encrypted Values</a> section to know more about encryption.</p>
<h3 id="deployers">deployers</h3>
<p>This section defines one or more deployer definition.  Each deployer definition consists of different settings to be used for deploying given application and url of the deployer. Typically, the urls can be defined in separate totem file (cluster-def.yml), while the applications specific settings can be added in totem.yml file.</p>
<h3 id="hooks">hooks</h3>
<p>This section defines one or more hooks that is being enabled for the given application. The hooks may be a CI hook or builder hook.</p>
<h3 id="notifications">notifications</h3>
<p>This section defines one or more notifiers (e.g: github, hipchat) to be used for given application to send success/failed notifications.</p>
<h3 id="environment">environment</h3>
<p>This section defines top level environment variables used by application template. The value defined can be</p>
<ul>
<li>Raw string </li>
<li>Encrypted Values (Refer <a href="README.md#encrypted-values">Encrypted Values</a> section to know more about encryption.)</li>
<li>Templated Values</li>
</ul>
<p>e.g.: </p>
<pre><code class="lang-yaml">environment:
  env1: &quot;value1&quot;
  env2:
    value: &quot;{{variable2}}&quot;
  env3:
    value: |
      # if ref == &#39;master&#39;
      ******encrypted value for master ******
      # else
      ******encrypted value for non master ******
      # endif
    encrypted: true
</code></pre>

    </div>
  </div>
  <footer class="site-footer"></footer>
  <script >(function(){
	/* Did we just livereload? */
var log = !!(localStorage && console && console.log && true);
if ( log && localStorage.getItem('/docpad-livereload/reloaded') === 'yes' ) {
	localStorage.removeItem('/docpad-livereload/reloaded');
	console.log('LiveReload completed at', new Date())
}

/* Listen for the regenerated event and perform a reload of the page when the event occurs */
var listen = function(){
	var primus = new Primus('/docpad-livereload');
	primus.on('data', function(data){
		if ( data && data.message ) {
			if ( data.message === 'generateBefore' ) {
				if ( log ) {
					console.log('LiveReload started at', new Date());
				}
				if ( typeof document.getElementsByTagName !== 'undefined' ) {
	document.getElementsByTagName('html')[0].className += ' wait';
}
			}
			else if ( data.message === 'generateAfter' ) {
				if ( log ) {
					localStorage.setItem('/docpad-livereload/reloaded', 'yes');
				}
				document.location.reload();
			}
		}
	});
};
	/* Inject socket into our page */
var inject = function(){
	var t = document.createElement('script');
	t.type = 'text/javascript';
	t.async = 'async';
	t.src = '/primus/primus.js';
	t.onload = listen;
	var s = document.getElementsByTagName('script')[0];
	s.parentNode.insertBefore(t, s);
};
	if ( typeof Primus !== 'undefined' ) {
		listen();
	} else {
		inject();
	}
})();</script><script defer="defer"  src="scripts/vendor/vendor.js"></script><script defer="defer"  src="scripts/main.js"></script>
</body>
</html>
